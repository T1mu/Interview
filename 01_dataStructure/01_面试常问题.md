## 数组和指针
- 逻辑结构：数组长度固定，不能适应动态增减；链表动态分配内存，可以适应动态增减的情况，且可以方面删查数据项。
- 内存：数组从栈中分配内存，对于程序员更方便快捷，但是自由度小。链表从堆中分配内存，麻烦，但是自由度高。
- 访问：数组在内存中连续储存，用下标索引访问；链表是链式储存结构，在访问元素时只能从前向后线性访问，所以访问效率比数组低。

## 快排
选择一个基准元素，通常是第一个或者最后一个元素，通过一趟排序将待排的数据分割成2个部分，一部分小于基准元素，另一部分大于基准元素，然后再堆剩余的两个部分用同样的方法排序。

### 单
```c++
#include <iostream>

int split(int a[], int low, int high){
    int base = a[low];
    int i = low;
    for(int j = low+1;j <= high;j++){
        if(a[j]<=base)
        {
            i++;
            std::swap(a[j],a[i]);
        }
    }
    std::swap(a[low],a[i]);
    return i;
}
void quickSort(int a[], int low, int high){
    if(low<high){
        int mid = split(a,low,high);
        quickSort(a, low, mid-1);
        quickSort(a, mid+1, high);
    }
}

int main() {
    int a[] = {4,10,2,7,3,8,5,5};
    int size = sizeof(a)/ sizeof(a[0]);
    quickSort(a, 0, size-1);
    for(int i = 0; i!=size;i++) {
        printf("%d ",a[i]);
    }
}

```

### 双
```c++
#include <iostream>

using namespace std;

int partion(int a[], int low, int high){
    int base = a[low];
    int i = low;
    int j = high;
    while(i<j){
        while (a[j]>base && i<j)
            j--;
        a[i]=a[j];
        while(a[i]<=base && i<j)
            i++;
        a[j]=a[i];
    }
    a[i]=base;
    return i;
}
void quickSort(int a[], int low, int high){
    if(low<high){
        int mid =partion(a,low,high);
        quickSort(a, mid+1, high);
        quickSort(a, low, mid-1);
    }
}

int main() {
    int a[] = {95,27,95,95};
    int size = sizeof(a)/sizeof(a[0]);
    quickSort(a,0,size-1);
    for(int i = 0; i!=size; i++){
        std::cout<<a[i]<<" ";
    }
}

```

## 树

### AVL树
AVL树是根据它的发明者G. M. Adelson-Velskii和E. M. Landis命名的。它是一种特殊的二叉搜索树。AVL树要求: 任一节点的左子树深度和右子树深度相差不超过1